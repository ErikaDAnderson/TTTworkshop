---
output:
  pdf_document: default
  html_document: default
---
# DAY 1

## MOTIVATION FOR THE WORKSHOP (EDWARDS AND DUPLISEA)

This workshop was motivated by several recent developments:

(1) The TESA Template Model Builder (TMB) course in Halifax in January 2018 introduced many DFO assessment scientists to tools such as github and the advantages of a strong versioning system, centralised methods repositories and the ability to share code. Git and Github was already well used at the Pacific Biological Station but not so much in other DFO labs and the national advantages of this became clearer after the TMB course.

(2) ICES has developed an initiative called the [Transparent Assessment Framework (TAF)](https://github.com/ices-taf) that works towards TTT goals. ICES representatives gave a webinar to TESA in the Spring of 2017 on this initiative and has been a source of inspiration in moving on this TTT workshop.

(3) There has been a desire in DFO to create a common look and feel in DFO science advice in assessment. Previous experience has shown that this does not work well when pushed from the top down but use of these modern sharing tools should help create some common looking outputs as emergent products of this way of working.

(4) Bill C-68 (changes to the Fisheries Act) is currently in the Senate. C-68 contains specific wording around the need to develop limit reference points and recovery plans. The legislated need for these products that come from assesssment scientists' workbenches is a motivating factor to work clearly in a TTT framework.

(5) The need to develop bilingual documentation for all DFO web published documents and in often during assessment peer review processes motivates the development of translation tools for tables and graphics that can be done consistently, relatively instantly and across all regions. The fourth and appropriately silent T in TTT can be considered translation but in reality is no less important than the others.

## MOTIVATION FOR USING Git (EDWARDS)

Emailing individual files does not preserve folder structure, which is important for code functionality, particularly when building complicated models with nested functions.
GitHub is more efficient and less prone to errors by preserving folder structure and allows analysts to work on code simultaneously.

GitHub tracks changes in a document and keeps all previous changes, so that previous versions are never lost. 
By using branches, individual developers can simultaneously work on the same project without worrying about overwriting each others work.
Git merges versions of the document edited by different users, and highlights lines with conflicts that need to be resolved.
Git also tracks who made which changes, which can be viewed using the blame button. 
During development (or post-development), Git also allows analysts to easily reference pieces of code and/or changes in code easily when posing questions or issues, using remote repositories.
Issues can be easily tracked on the GitHub site and used as a continuously updated to-do list, with a permanently recorded history.
Individual issues that need to be addressed can also be assigned to specific analysts within a working group.

## INTERACTIVE INTRODUCTION TO Git (EDWARDS AND GRANDIN)

Chris and Andy led the group though the steps for basic Git functions:

- Creating a remote repository on a host site (e.g., GitHub)
  - also included adding a `.gitignore` file that specifies files that Git should not track (e.g., data files);
- Cloning the repository to your local hard drive;
- Adding a file to the repository;
- Committing the file with an informative message;
- Editing files;
- Committing changes to update the document;
- Pushing to the remote repository; and
- Referencing previous commits using their `HASH`.

We also made a `.gitconfig` file that includes useful keyboard shortcuts. 

Next Andy addressed a family of Git functions that are more likely to be used during a collaboration:

- Making a new branch separate from the master;
- Merging branches, and addressing any conflicts that arise;
- Pushing branches upstream so they can be accessed by others;
- Deleting old branches to keep your workspace tidy;
- Stashing changes that have not been committed when you switch branches;
- Examining network graphs (on GitHub site) to interpret branch structure;
- Adding remotes (besides `master`), and fetching collaborators changes from them; and
- Use `git diff` to compare changes between collaborators `master` and your `master`.
